import re
from io import StringIO
from pathlib import Path
from zipfile import ZipFile, ZIP_DEFLATED
from os import walk, getcwd, chdir, symlink, readlink, name as osname, stat, unlink, chmod
import os.path as op
from shutil import rmtree, copytree
import lzma
import subprocess
from sys import stdout
from hashlib import md5
from .bootimg import unpack_bootimg, repack_bootimg
from .imgextractor import Extractor
from .configs import (
    make_ext4fs_bin,
    magiskboot_bin,
    img2simg_bin,
    simg2img_bin
)

from .sdat2img import main as sdat2img
from .img2sdat import main as img2sdat

from .boot_patch import BootPatcher, parseMagiskApk
import glob

if osname == 'nt':
    from ctypes import windll, wintypes

tool_author = 'affggh'; tool_version = '1.1145141919810'

class proputil:
    def __init__(self, propfile: str):
        proppath = Path(propfile)
        if proppath.exists():
            self.propfile = propfile
            self.encoding = self.__detect_encoding(propfile)
            self.propfd = Path(propfile).open('r+', encoding=self.encoding)
        else:
            raise FileExistsError(f"File {propfile} does not exist!")
        self.prop = self.__loadprop

    def __detect_encoding(self, filepath):
        encodings = ['utf-8', 'gbk', 'latin-1', 'gb18030']
        for encoding in encodings:
            try:
                with open(filepath, 'r', encoding=encoding) as f:
                    f.readlines()
                return encoding
            except UnicodeDecodeError:
                continue
        return 'latin-1'  # 默认回退编码

    @property
    def __loadprop(self) -> list:
        with open(self.propfile, 'r', encoding=self.encoding) as f:
            return f.readlines()

    def getprop(self, key: str) -> str | None:
        for i in self.prop:
            if i.startswith(key): return i.rstrip().split('=')[1]
        return None
    
    def setprop(self, key, value) -> None:
        flag: bool = False
        for index, current in enumerate(self.prop):
            if key in current:
                if not value: value = ''
                self.prop[index] = current.split('=')[0] + '=' + value + '\n'
                flag = True
        if not flag:
            self.prop.append(key + '=' + value + '\n')

    def save(self):
        self.propfd.seek(0, 0)
        self.propfd.truncate()
        self.propfd.writelines(self.prop)
        self.propfd.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.save()

class updaterutil:
    def __init__(self, fd):
        self.fd = fd
        if not self.fd:
            raise IOError("fd is not valid!")
        self.content = self.__parse_commands
    
    @property
    def __parse_commands(self):
        self.fd.seek(0, 0)
        commands = re.findall(r'(\w+)\((.*?)\)', self.fd.read().replace('\n', ''))
        parsed_commands = [[command, *(arg[0] or arg[1] or arg[2] for arg in re.findall(r'(?:"([^"]+)"|(\b\d+\b)|(\b\S+\b))', args))] for command, args in commands]
        return parsed_commands

    def generate(self, author: str, version: str, partitions: dict):
        def add_quotes_if_needed(arg):
            return arg if arg.isdigit() else f'"{arg}"'
        if not partitions.get("system") or not partitions.get("boot"):
            return None
        self.fd.seek(0, 0)
        updater_script = self.fd.read().replace('\n', '')
        pattern = r'(\w+)\((.*?)\)'
        commands = re.findall(pattern, updater_script)
        filtered_commands = [(command, *(arg[0] or arg[1] or arg[2] for arg in re.findall(r'(?:"([^"]+)"|(\b\d+\b)|(\b\S+\b))', args))) for command, args in commands if command in {'symlink', 'set_metadata_recursive', 'set_metadata'}]
        updater_script_content = [f"{command}({', '.join(map(add_quotes_if_needed, args))});" for command, *args in filtered_commands]

        full_commands = [
            "ui_print(\"\");",
            "ui_print(\"======== Auto Generated By MTK PORT TOOL ========\");",
            f"ui_print(\"- Author: {author}\");",
            f"ui_print(\"- Version: {version}\");",
            f"ui_print(\"- MTK PORT TOOL Info below:\");",
            f"ui_print(\"    TOOL Author: {tool_author}\");",
            f"ui_print(\"    TOOL Version: {tool_version}\");",
            f"ui_print(\"{'='*49}\");",
            f"ifelse(is_mounted(\"/system\"), unmount(\"/system\"));",
            f"run_program(\"mke2fs\", \"{partitions['system']}\");",
            f"format(\"ext4\", \"EMMC\", \"/dev/block/mmcblk0p4\", \"0\", \"/system\");",
            "set_progress(0.1);",
            "ui_print(\"- Mounting system partition...\");",
            f"mount(\"ext4\", \"EMMC\", \"{partitions['system']}\", \"/system\", \"max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc\");",
            "ui_print(\"- Extract system conditionally...\");",
            "set_progress(0.2);",
            "package_extract_dir(\"system\", \"/system\");",
            "set_progress(0.5);",
            "ui_print(\"- Create symlinks and setup metadata...\");",
            *updater_script_content,
            "set_progress(0.8);",
            "ui_print(\"- Flash boot image...\");",
            f"package_extract_file(\"boot.img\", \"{partitions['boot']}\");",
            "set_progress(0.9);",
            "ui_print(\"- Done!\");",
            "unmount(\"/system\");",
            "set_progress(1);",
        ]
        return "\n".join(full_commands)

class ziputil:
    def __init__(self):
        pass
    
    def decompress(zippath: str, outdir: str):
        with ZipFile(zippath, 'r') as zipf:
            zipf.extractall(outdir)
    
    def extract_onefile(zippath: str, filename: str, outpath: str):
        with ZipFile(zippath, 'r') as zipf:
            zipf.extract(filename, outpath)
    
    def compress(zippath: str, indir: str):
        with ZipFile(zippath, 'w', ZIP_DEFLATED) as zipf:
            for root, dirs, files in walk(indir):
                for file in files:
                    file_path = op.join(root, file)
                    zip_path = op.relpath(op.abspath(file_path), op.abspath(indir))
                    zipf.write(file_path, zip_path)

class xz_util:
    def __init__(self):
        pass

    def compress(src_file_path, dest_file_path):
        with open(src_file_path, 'rb') as src_file:
            with lzma.open(dest_file_path, 'wb') as dest_file:
                dest_file.write(src_file.read())

class bootutil:
    def __init__(self, bootpath):
        self.bootpath = op.abspath(bootpath)
        self.bootdir = op.dirname(self.bootpath)
        self.retcwd = getcwd()
    
    def unpack(self):
        chdir(self.bootdir)
        unpack_bootimg(self.bootpath)
        chdir(self.retcwd)
    
    def repack(self):
        chdir(self.bootdir)
        with open("bootinfo.txt", encoding='ascii') as f:
            (
                base,
                ramdisk_addr,
                second_addr,
                tags_addr,
                page_size,
                name,
                cmdline,
                padding_size,
            ) = [i.lstrip("\x00").rstrip().split(':')[1] for i in iter(f.readline, "")]
        repack_bootimg(base, cmdline, page_size, padding_size, None)
        chdir(self.retcwd)
    
    def __entry__(self):
        return self

    def __exit__(self, *vars):
        chdir(self.retcwd)

class portutils:
    def __init__(self, items: dict, bootimg: str, sysimg: str, port_source, source_type: str, genimg: bool = False, stdlog = None):
        self.items = items
        self.sysimg = sysimg
        self.bootimg = bootimg
        self.port_source = port_source  # zip路径 或 (boot.img, system.img)元组
        self.source_type = source_type  # 'zip' 或 'img'
        self.genimg = genimg  # True=输出img，False=输出zip
        self.outdir = Path("out")
        if not self.outdir.exists():
            self.outdir.mkdir(parents=True)
        self.std = stdlog if stdlog else stdout
        if not self.__check_exist:
            print("【检查失败】文件是否存在检查不通过", file=self.std)
            return
        self.sdat = False
    
    @property
    def __check_exist(self) -> bool:
        # 检查底包
        for i in (self.sysimg, self.bootimg):
            if not Path(i).exists():
                print(f"【缺失文件】底包文件 {i} 不存在", file=self.std)
                return False
        # 检查移植源
        if self.source_type == 'zip':
            if not Path(self.port_source).exists():
                print(f"【缺失文件】移植包 {self.port_source} 不存在", file=self.std)
                return False
        else:
            port_boot, port_sys = self.port_source
            if not Path(port_boot).exists():
                print(f"【缺失文件】移植用boot.img {port_boot} 不存在", file=self.std)
                return False
            if not Path(port_sys).exists():
                print(f"【缺失文件】移植用system.img {port_sys} 不存在", file=self.std)
                return False
        return True

    def execv(self, cmd, verbose=False):
        """
        执行系统命令（优化版）
        :param cmd: 命令列表
        :param verbose: 是否输出原始命令和完整输出
        :return: (返回码, 命令输出字节串)
        """
        if verbose:
            print(f"【执行命令】{' '.join(cmd)}", file=self.std)
        
        creationflags = subprocess.CREATE_NO_WINDOW if osname == 'nt' else 0
        try:
            ret = subprocess.run(
                cmd,
                shell=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                creationflags=creationflags
            )
            cmd_output = ret.stdout
            ret_code = ret.returncode
        except Exception as e:
            err_msg = f"【执行失败】无法执行命令：{str(e)}"
            self.std.write(err_msg + "\n")
            return (-1, err_msg.encode('utf-8'))
        
        if verbose:
            output_str = cmd_output.decode('utf-8', errors='ignore')
            print(f"【命令输出】{output_str}", file=self.std)
        
        return (ret_code, cmd_output)

    def __decompress_portzip(self):
        outdir = Path("tmp/rom")
        if outdir.exists():
            print(f"【清理临时文件】删除已有 tmp/rom 目录", file=self.std)
            rmtree(outdir)
        outdir.mkdir(parents=True)
        
        if self.source_type == 'zip':
            print(f"【解压移植包】正在解压 {self.port_source} 到 tmp/rom...", file=self.std)
            ziputil.decompress(self.port_source, str(outdir))
            print(f"【解压完成】移植包已解压到 tmp/rom", file=self.std)
        else:
            print(f"【复制镜像】正在复制移植用镜像文件到 tmp/rom...", file=self.std)
            port_boot, port_sys = self.port_source
            # 复制到tmp/rom供后续处理
            Path(outdir.joinpath("boot.img")).write_bytes(Path(port_boot).read_bytes())
            Path(outdir.joinpath("system.img")).write_bytes(Path(port_sys).read_bytes())
            print(f"【复制完成】boot.img和system.img已复制到 tmp/rom", file=self.std)
    
    def __port_boot(self) -> bool:
        def __replace(src: Path, dest: Path):
            print(f"【文件替换】{src.name} -> {dest.parent}/{dest.name}...", file=self.std)
            dest.write_bytes(src.read_bytes())
            return True
        
        basedir = Path("tmp/base")
        portdir = Path("tmp/port")
        
        # 清理旧目录
        if basedir.exists():
            rmtree(basedir)
        if portdir.exists():
            rmtree(portdir)
        basedir.mkdir(parents=True)
        portdir.mkdir(parents=True)
        
        # 复制底包boot.img并解包
        print(f"【处理底包】复制底包boot.img到 tmp/base...", file=self.std)
        basedir.joinpath("boot.img").write_bytes(Path(self.bootimg).read_bytes())
        base = basedir.joinpath("boot.img")
        
        # 处理移植源boot.img
        if self.source_type == 'zip':
            try:
                print(f"【提取boot.img】从移植包中提取boot.img...", file=self.std)
                ziputil.extract_onefile(self.port_source, "boot.img", "tmp/port/")
            except Exception as e:
                err_msg = f"【提取失败】无法从移植包解压boot.img：{str(e)}"
                print(err_msg, file=self.std)
                return False
        else:
            port_boot, _ = self.port_source
            print(f"【复制boot.img】复制移植用boot.img到 tmp/port...", file=self.std)
            Path("tmp/port/boot.img").write_bytes(Path(port_boot).read_bytes())
        
        port = Path(portdir.joinpath("boot.img"))
        
        # 解包boot.img
        print(f"【解包boot.img】正在解包底包boot.img...", file=self.std)
        bootutil(str(base)).unpack()
        print(f"【解包boot.img】正在解包移植源boot.img...", file=self.std)
        bootutil(str(port)).unpack()
        
        # 执行boot移植逻辑
        print(f"【开始移植】执行boot.img移植逻辑...", file=self.std)
        for item in self.items['flags']:
            item_flag = self.items['flags'][item]
            if not item_flag:
                continue
            
            match item:
                case 'replace_kernel':
                    print(f"【移植项】替换内核文件...", file=self.std)
                    for i in self.items['replace']['kernel']:
                        if basedir.joinpath(i).exists():
                            print(f"  - 替换 {i}", file=self.std)
                            __replace(basedir.joinpath(i), portdir.joinpath(i))
                        else:
                            print(f"  - 跳过 {i}（底包中不存在）", file=self.std)
                case 'replace_fstab':
                    print(f"【移植项】替换分区表文件...", file=self.std)
                    for i in self.items['replace']['fstab']:
                        if basedir.joinpath(i).exists():
                            print(f"  - 替换 {i}", file=self.std)
                            __replace(basedir.joinpath(i), portdir.joinpath(i))
                        else:
                            print(f"  - 跳过 {i}（底包中不存在）", file=self.std)
                case 'selinux_permissive':
                    print(f"【移植项】开启SELinux宽容模式...", file=self.std)
                    if portdir.joinpath("bootinfo.txt").exists():
                        with portdir.joinpath("bootinfo.txt").open("r+") as f:
                            lines = [i.rstrip() for i in f.readlines()]
                            if any("androidboot.selinux=permissive" in line for line in lines):
                                print(f"  - 已开启SELinux宽容模式，无需重复操作", file=self.std)
                                continue
                            f.truncate(0)
                            for line in lines:
                                if line.startswith("cmdline:"):
                                    f.write(line + " androidboot.selinux=permissive\n")
                                else:
                                    f.write(line + '\n')
                        print(f"  - SELinux宽容模式已开启", file=self.std)
                    else:
                        print(f"  - 跳过（未找到bootinfo.txt）", file=self.std)
                case 'enable_adb':
                    print(f"【移植项】开启ADB调试...", file=self.std)
                    if portdir.joinpath("initrd/default.prop").exists():
                        with proputil(str(portdir.joinpath("initrd/default.prop"))) as p:
                            kv = [
                                ('ro.secure', '0'), 
                                ('ro.adb.secure', '0'), 
                                ('ro.debuggable', '1'), 
                                ('persist.sys.usb.config', 'mtp,adb')
                            ]
                            for key, value in kv:
                                p.setprop(key, value)
                                print(f"  - 设置 {key} = {value}", file=self.std)
                        print(f"  - ADB调试已开启", file=self.std)
                    else:
                        print(f"  - 跳过（未找到default.prop）", file=self.std)
        
        # 重新打包boot.img
        print(f"【打包boot.img】正在重新打包移植后的boot.img...", file=self.std)
        bootutil(str(port)).repack()
        outboot = Path(portdir.joinpath("boot-new.img"))
        to = Path("tmp/rom/boot.img")
        __replace(outboot, to)
        
        # Magisk修补
        if self.items.get("patch_magisk") and op.isfile(self.items.get("magisk_apk")):
            print(f"【Magisk修补】开始修补boot.img...", file=self.std)
            parseMagiskApk(self.items['magisk_apk'], self.items['target_arch'], self.std)
            bp = BootPatcher(magiskboot_bin, legacysar=True, log=self.std)
            if bp.patch(str(to)):
                __replace(Path("new-boot.img"), to)
                unlink("new-boot.img")
                print(f"【Magisk修补】boot.img修补完成", file=self.std)
            else:
                print(f"【Magisk修补】boot.img修补失败", file=self.std)
            bp.cleanup()
        else:
            if self.items.get("patch_magisk"):
                print(f"【Magisk修补】跳过（未找到magisk.apk）", file=self.std)
        
        print(f"【boot移植完成】boot.img处理完毕", file=self.std)
        return True

    def __port_system(self):
        def __replace(val: str):
            print(f"【文件替换】底包/{val} -> 移植源/{val}...", file=self.std)
            if "*" in val:
                for file in glob.glob(op.join(str(base_prefix), val)):
                    relfile = op.relpath(file, str(base_prefix))
                    port_prefix.joinpath(relfile).write_bytes(base_prefix.joinpath(relfile).read_bytes())
                    print(f"  - 替换通配文件 {file}", file=self.std)
            elif base_prefix.joinpath(val).is_dir():
                if port_prefix.joinpath(val).exists():
                    rmtree(port_prefix.joinpath(val))
                copytree(base_prefix.joinpath(val), port_prefix.joinpath(val))
                print(f"  - 替换目录 {val}", file=self.std)
            else:
                port_prefix.joinpath(val).write_bytes(base_prefix.joinpath(val).read_bytes())
                print(f"  - 替换文件 {val}", file=self.std)
        
        # 检查并解包底包system.img
        unpack_flag = False
        with open(self.sysimg, 'rb') as f:
            sysmd5 = md5(f.read()).hexdigest()
        md5path = Path("base/system.md5")
        
        if not md5path.exists() or md5path.read_text().strip() != sysmd5:
            unpack_flag = True
            md5path.parent.mkdir(parents=True, exist_ok=True)
            md5path.write_text(sysmd5)
            if Path("base/system").exists():
                print(f"【清理缓存】删除旧的base/system目录（MD5不一致）", file=self.std)
                rmtree("base/system")
        
        if unpack_flag:
            print(f"【解包system.img】正在解包底包system.img到 base/system...", file=self.std)
            Extractor().main(self.sysimg, "base/system")
            print(f"【解包完成】底包system.img解包完毕", file=self.std)
        else:
            print(f"【使用缓存】base/system目录已存在且MD5一致，跳过解包", file=self.std)
        
        # 解包移植源system.img
        if Path("tmp/rom/system.new.dat").exists():
            print(f"【格式转换】检测到system.new.dat，转换为img格式...", file=self.std)
            self.sdat = True
            with open("tmp/rom/system.transfer.list") as t:
                self.sdat_ver = int(t.readline().rstrip())
            sdat2img("tmp/rom/system.transfer.list", "tmp/rom/system.new.dat", "tmp/rom/system.img")
            print(f"【转换完成】system.new.dat已转为system.img", file=self.std)
        
        if Path("tmp/rom/system.img").exists():
            print(f"【解包system.img】正在解包移植源system.img到 tmp/rom/system...", file=self.std)
            Extractor().main("tmp/rom/system.img", "tmp/rom/system")
            print(f"【解包完成】移植源system.img解包完毕", file=self.std)
        
        # 执行system移植逻辑
        print(f"【开始移植】执行system.img移植逻辑...", file=self.std)
        base_prefix = Path("base/system")
        port_prefix = Path("tmp/rom/system")
        
        for item in self.items['flags']:
            item_flag = self.items[item]
            if not item_flag or item in ['replace_kernel', 'replace_fstab']:
                continue
            
            if item.startswith("replace_"):
                replace_type = item.split('_')[1]
                print(f"【移植项】替换{replace_type}相关文件...", file=self.std)
                for i in self.items['replace'][replace_type]:
                    if base_prefix.joinpath(i).exists() or "*" in i:
                        __replace(i)
                    else:
                        print(f"  - 跳过 {i}（底包中不存在）", file=self.std)
                continue
            
            match item:
                case 'single_simcard' | 'dual_simcard':
                    sim_type = "单卡" if item == 'single_simcard' else "双卡"
                    print(f"【移植项】修改为{sim_type}模式...", file=self.std)
                    with proputil(str(port_prefix.joinpath("build.prop"))) as p:
                        kv = [
                            ('persist.multisim.config', 'ss' if item == 'single_simcard' else 'dsds'),
                            ('persist.radio.multisim.config', 'ss' if item == 'single_simcard' else 'dsds'),
                            ('ro.telephony.sim.count', '1' if item == 'single_simcard' else '2'),
                            ('persist.dsds.enabled', 'false' if item == 'single_simcard' else 'true'),
                            ('ro.dual.sim.phone', 'false' if item == 'single_simcard' else 'true')
                        ]
                        for key, value in kv:
                            p.setprop(key, value)
                            print(f"  - 设置 {key} = {value}", file=self.std)
                    print(f"  - {sim_type}模式已配置完成", file=self.std)
                case 'fit_density':
                    print(f"【移植项】同步底包屏幕DPI...", file=self.std)
                    with proputil(str(port_prefix.joinpath("build.prop"))) as pp, proputil(str(base_prefix.joinpath("build.prop"))) as bp:
                        dpi_value = bp.getprop('ro.sf.lcd_density')
                        if dpi_value:
                            pp.setprop('ro.sf.lcd_density', dpi_value)
                            print(f"  - 同步DPI值：{dpi_value}", file=self.std)
                        else:
                            print(f"  - 跳过（底包中未找到ro.sf.lcd_density）", file=self.std)
                case 'change_timezone':
                    print(f"【移植项】同步底包时区...", file=self.std)
                    with proputil(str(port_prefix.joinpath("build.prop"))) as pp, proputil(str(base_prefix.joinpath("build.prop"))) as bp:
                        timezone = bp.getprop('persist.sys.timezone')
                        if timezone:
                            pp.setprop('persist.sys.timezone', timezone)
                            print(f"  - 同步时区：{timezone}", file=self.std)
                        else:
                            print(f"  - 跳过（底包中未找到persist.sys.timezone）", file=self.std)
                case 'change_locale':
                    print(f"【移植项】同步底包语言区域...", file=self.std)
                    with proputil(str(port_prefix.joinpath("build.prop"))) as pp, proputil(str(base_prefix.joinpath("build.prop"))) as bp:
                        locale = bp.getprop('ro.product.locale')
                        if locale:
                            pp.setprop('ro.product.locale', locale)
                            print(f"  - 同步语言区域：{locale}", file=self.std)
                        else:
                            print(f"  - 跳过（底包中未找到ro.product.locale）", file=self.std)
                case 'enable_adb':
                    print(f"【移植项】开启ADB调试...", file=self.std)
                    build_prop_path = port_prefix.joinpath("build.prop")
                    if build_prop_path.exists():
                        with proputil(str(build_prop_path)) as p:
                            kv = [
                                ('ro.secure', '0'),
                                ('ro.adb.secure', '0'),
                                ('ro.debuggable', '1'),
                                ('persist.sys.usb.config', 'mtp,adb')
                            ]
                            for key, value in kv:
                                p.setprop(key, value)
                                print(f"  - 设置 {key} = {value}", file=self.std)
                        print(f"  - ADB调试已在build.prop中开启", file=self.std)
                    else:
                        print(f"  - 跳过（未找到system/build.prop）", file=self.std)            
                case 'change_model':
                    print(f"【移植项】同步底包设备型号信息...", file=self.std)
                    keys = ['ro.product.manufacturer', 'ro.build.product', 'ro.product.model', 'ro.product.device', 'ro.product.board', 'ro.product.brand']
                    with proputil(str(port_prefix.joinpath("build.prop"))) as pp, proputil(str(base_prefix.joinpath("build.prop"))) as bp:
                        for key in keys:
                            value = bp.getprop(key)
                            if value:
                                pp.setprop(key, value)
                                print(f"  - 设置 {key} = {value}", file=self.std)
                            else:
                                print(f"  - 跳过 {key}（底包中未找到）", file=self.std)
                    print(f"  - 设备型号信息同步完成", file=self.std)
        
        print(f"【system移植完成】system.img处理完毕", file=self.std)
        return True
    
    def __pack_rom(self):
        print(f"【开始打包】生成zip卡刷包...", file=self.std)
        # 执行卡刷包定制逻辑
        for item in self.items['flags']:
            item_flag = self.items['flags'][item]
            if not item_flag:
                continue
            
            match item:
                case 'use_custom_update-binary':
                    print(f"【定制项】使用自定义update-binary...", file=self.std)
                    update_binary_path = Path("tmp/rom/META-INF/com/google/android/update-binary")
                    update_binary_path.parent.mkdir(parents=True, exist_ok=True)
                    update_binary_path.write_bytes(Path("bin/update-binary").read_bytes())
                    print(f"  - 自定义update-binary已替换", file=self.std)
                case 'generate_script':
                    print(f"【定制项】生成自动刷机脚本...", file=self.std)
                    updater_script_path = Path("tmp/rom/META-INF/com/google/android/updater-script")
                    if updater_script_path.exists():
                        with updater_script_path.open('r+', encoding='utf-8') as f:
                            author = self.items.get('author') or tool_author
                            version = self.items.get('version') or tool_version
                            new_script = updaterutil(f).generate(author, version, self.items['partitions'])
                            if new_script:
                                f.seek(0, 0)
                                f.truncate()
                                f.write(new_script)
                                print(f"  - 刷机脚本生成成功", file=self.std)
                            else:
                                print(f"  - 刷机脚本生成失败（分区信息缺失）", file=self.std)
                    else:
                        print(f"  - 跳过（未找到updater-script）", file=self.std)
        
        # 打包zip
        outpath = Path(f"out/{op.basename(self.port_source)}")
        if outpath.exists():
            print(f"【清理旧文件】删除已有 {outpath.name}", file=self.std)
            outpath.unlink()
        
        if self.sdat:
            print(f"【格式处理】使用SDAT格式打包system分区...", file=self.std)
            config_dir = Path("tmp/rom/config")
            config_dir.mkdir(parents=True, exist_ok=True)
            
            # 清理文件上下文配置
            fc_path = config_dir.joinpath("system_file_contexts")
            if fc_path.exists():
                with fc_path.open('r+') as fc:
                    fc_info = list(dict.fromkeys([i.rstrip() for i in fc]))
                    fc.seek(0, 0)
                    fc.truncate()
                    fc.write("\n".join(fc_info))
                print(f"  - 清理重复的文件上下文配置", file=self.std)
            
            # 生成文件系统配置
            fs_label = [["/", '0', '0', '0755'], ["/lost\\+found", '0', '0', '0700']]
            fs_files = [i[0] for i in fs_label]
            
            for root, dirs, files in walk("tmp/rom/system"):
                if "tmp/install" in root.replace('\\', '/'):
                    continue
                for dir in dirs:
                    unix_path = op.join("/system", op.relpath(op.join(root, dir), "tmp/rom/system")).replace("\\", "/").replace("[", "\\[")
                    if unix_path not in fs_files:
                        fs_label.append([unix_path.lstrip('/'), '0', '0', '0755'])
                        fs_files.append(unix_path)
                for file in files:
                    unix_path = op.join("/system", op.relpath(op.join(root, file), "tmp/rom/system")).replace("\\", "/").replace("[", "\\[")
                    if unix_path not in fs_files:
                        link = self.__readlink(op.join(root, file))
                        if link:
                            fs_label.append([unix_path.lstrip('/'), '0', '2000', '0755', link])
                        else:
                            mode = '0755' if "bin/" in unix_path else '0644'
                            fs_label.append([unix_path.lstrip('/'), '0', '2000', mode])
                        fs_files.append(unix_path)
            
            # 写入文件系统配置
            with config_dir.joinpath("system_fs_config").open('w') as f:
                for fs in sorted(fs_label):
                    f.write(" ".join(fs) + '\n')
            print(f"  - 生成文件系统配置：{len(fs_label)} 条记录", file=self.std)
            
            # 生成raw镜像
            fit_size = self.__pack_fit_size()
            sys_size = stat(self.sysimg).st_size
            img_size = sys_size if sys_size >= fit_size else fit_size
            
            print(f"【生成镜像】创建system_raw.img（大小：{round(img_size/(1024**3),2)}GB）...", file=self.std)
            ret_code, _ = self.execv([
                make_ext4fs_bin, '-s', '-J', '-T', '1', '-l', f'{img_size}',
                '-C', str(config_dir.joinpath('system_fs_config')), 
                '-S', str(config_dir.joinpath('system_file_contexts')),
                '-L', 'system', '-a', 'system', 
                "out/system_raw.img", "tmp/rom/system"
            ], verbose=False)
            
            if ret_code != 0:
                print(f"【生成失败】system_raw.img创建失败（返回码：{ret_code}）", file=self.std)
                return
            
            # 转换为稀疏镜像
            print(f"【格式转换】将system_raw.img转为稀疏镜像...", file=self.std)
            ret_code, _ = self.execv([img2simg_bin, "out/system_raw.img", "out/system.img"], verbose=False)
            if ret_code != 0:
                print(f"【转换失败】稀疏镜像生成失败（返回码：{ret_code}）", file=self.std)
                return
            
            # 转换为SDAT格式
            print(f"【格式转换】将system.img转为SDAT格式...", file=self.std)
            rmtree("tmp/rom/system")
            img2sdat("out/system.img", "tmp/rom", self.sdat_ver)
            if Path("tmp/rom/system.img").exists():
                unlink("tmp/rom/system.img")
            print(f"  - SDAT格式转换完成", file=self.std)
        
        # 最终打包zip
        print(f"【打包zip】正在压缩为卡刷包...", file=self.std)
        ziputil.compress(str(outpath), "tmp/rom/")
        print(f"【打包完成】卡刷包已生成：{outpath}", file=self.std)
    
    def __pack_img(self):
        """生成img镜像（日志优化核心方法）"""
        def __symlink(src: str, dest: str):
            pdest = Path(dest)
            pdest.parent.mkdir(parents=True, exist_ok=True)
            if osname == 'nt':
                with open(dest, 'wb') as f:
                    f.write(b"!<symlink>" + src.encode('utf-16') + b'\0\0')
                windll.kernel32.SetFileAttributesA(dest.encode('gb2312'), 0x4)
            else:
                symlink(src, dest)
        
        print(f"\n【开始打包】生成img镜像文件...", file=self.std)
        updater = Path("tmp/rom/META-INF/com/google/android/updater-script")
        config_dir = Path("tmp/config")
        
        # 清理旧配置
        if config_dir.exists():
            rmtree(config_dir)
        config_dir.mkdir(parents=True)
        
        # 解析刷机脚本获取权限配置（zip源）或使用默认配置（img源）
        print(f"【配置生成】解析权限配置（SD卡刷包源）...", file=self.std)
        fs_label = [["/", '0', '0', '0755'], ["/lost\\+found", '0', '0', '0700']]
        fc_label = [['/', 'u:object_r:system_file:s0'], ['/system(/.*)?', 'u:object_r:system_file:s0']]
        
        if updater.exists():
            with updater.open('r', encoding='utf-8') as f:
                contents = updaterutil(f).content
            
            last_fpath = ''
            for content in contents:
                command, *args = content
                match command:
                    case 'symlink':
                        src, *targets = args
                        for target in targets:
                            __symlink(src, str(Path("tmp/rom").joinpath(target.lstrip('/'))))
                    case 'set_metadata' | 'set_metadata_recursive':
                        dirmode = command == 'set_metadata_recursive'
                        fpath, *fargs = args
                        fpath = fpath.replace("+", "\\+").replace("[", "\\[").replace('//', '/')
                        if fpath == last_fpath:
                            continue
                        
                        # 解析权限参数
                        uid, gid, mode, extra = '0', '0', '644', ''
                        selable = 'u:object_r:system_file:s0'
                        for idx, farg in enumerate(fargs):
                            match farg:
                                case 'uid': uid = fargs[idx+1]
                                case 'gid': gid = fargs[idx+1]
                                case 'mode'|'fmode'|'dmode': 
                                    mode = fargs[idx+1] if (dirmode and farg == 'dmode') else fargs[idx+1]
                                case 'capabilities': 
                                    extra = 'capabilities=' + fargs[idx+1] if fargs[idx+1] != '0x0' else ''
                                case 'selabel': selable = fargs[idx+1]
                        
                        fs_label.append([fpath.lstrip('/'), uid, gid, mode, extra])
                        fc_label.append([fpath, selable])
                        last_fpath = fpath
            print(f"  - 从刷机脚本解析到 {len(fs_label)} 条权限配置", file=self.std)
        else:
            print(f"  - 未找到刷机脚本，使用默认权限配置", file=self.std)
        
        # 补充缺失的文件权限
        print(f"【配置生成】补充文件权限配置...", file=self.std)
        fs_files = [i[0] for i in fs_label]
        config_count = 0
        
        for root, dirs, files in walk("tmp/rom/system"):
            if "tmp/install" in root.replace('\\', '/'):
                continue
            
            for dir in dirs:
                unix_path = op.join("/system", op.relpath(op.join(root, dir), "tmp/rom/system")).replace("\\", "/").replace("[", "\\[")
                if unix_path not in fs_files:
                    fs_label.append([unix_path.lstrip('/'), '0', '0', '0755'])
                    fs_files.append(unix_path)
                    config_count += 1
            
            for file in files:
                unix_path = op.join("/system", op.relpath(op.join(root, file), "tmp/rom/system")).replace("\\", "/").replace("[", "\\[")
                if unix_path not in fs_files:
                    link = self.__readlink(op.join(root, file))
                    if link:
                        fs_label.append([unix_path.lstrip('/'), '0', '2000', '0755', link])
                    else:
                        mode = '0755' if "bin/" in unix_path else '0644'
                        fs_label.append([unix_path.lstrip('/'), '0', '2000', mode])
                    fs_files.append(unix_path)
                    config_count += 1
        
        print(f"  - 补充 {config_count} 条缺失的权限配置，总计 {len(fs_label)} 条", file=self.std)
        
        # 生成配置文件
        print(f"【配置生成】写入权限配置文件...", file=self.std)
        with config_dir.joinpath("system_fs_config").open('w') as f:
            for fs in sorted(fs_label):
                f.write(" ".join(filter(None, fs)) + '\n')
        
        with config_dir.joinpath("system_file_contexts").open('w') as f:
            for fc in sorted(fc_label):
                f.write(" ".join(fc) + '\n')
        print(f"  - 配置文件已写入到 tmp/config 目录", file=self.std)
        
        # 生成system.img（日志核心优化）
        fit_size = self.__pack_fit_size()
        sys_size = stat(self.sysimg).st_size
        img_size_bytes = sys_size if sys_size >= fit_size else fit_size
        img_size_gb = round(img_size_bytes / (1024**3), 2)
        
        # 结构化日志输出
        print(f"\n【生成system.img】核心参数说明：", file=self.std)
        print(f"  ├─ 工具：make_ext4fs（创建ext4格式分区镜像）", file=self.std)
        print(f"  ├─ 镜像大小：{img_size_gb} GB（{img_size_bytes} 字节）", file=self.std)
        print(f"  ├─ 镜像标签：system", file=self.std)
        print(f"  ├─ 挂载点：/system", file=self.std)
        print(f"  ├─ 权限配置：{config_dir}/system_fs_config", file=self.std)
        print(f"  ├─ SELinux上下文：{config_dir}/system_file_contexts", file=self.std)
        print(f"  ├─ 源目录：tmp/rom/system", file=self.std)
        print(f"  └─ 输出路径：out/system.img", file=self.std)
        
        print(f"\n【执行中】正在创建system.img文件系统...", file=self.std)
        make_ext4fs_cmd = [
            make_ext4fs_bin,
            '-J', '-T', '1', '-l', f'{img_size_bytes}',
            '-C', str(config_dir.joinpath('system_fs_config')),
            '-S', str(config_dir.joinpath('system_file_contexts')),
            '-L', 'system', '-a', 'system',
            "out/system.img", "tmp/rom/system"
        ]
        
        # 执行命令并获取输出
        ret_code, cmd_output = self.execv(make_ext4fs_cmd, verbose=False)
        cmd_output_str = cmd_output.decode('utf-8', errors='ignore')
        
        # 解析命令输出，提取关键信息
        if ret_code == 0:
            # 提取配置条目数
            fs_config_match = re.search(r'loaded (\d+) fs_config entries', cmd_output_str)
            fs_config_count = fs_config_match.group(1) if fs_config_match else "未知"
            
            # 提取镜像大小
            size_match = re.search(r'Size: (\d+)', cmd_output_str)
            if size_match:
                actual_size_gb = round(int(size_match.group(1)) / (1024**3), 2)
                actual_size_info = f"{actual_size_gb} GB"
            else:
                actual_size_info = f"{img_size_gb} GB（预估）"
            
            print(f"【生成成功】system.img创建完成！", file=self.std)
            print(f"  ├─ 权限配置条目：{fs_config_count} 条", file=self.std)
            print(f"  ├─ 实际镜像大小：{actual_size_info}", file=self.std)
            print(f"  └─ 输出路径：out/system.img", file=self.std)
        else:
            print(f"【生成失败】system.img创建失败！", file=self.std)
            print(f"  ├─ 返回码：{ret_code}", file=self.std)
            print(f"  └─ 错误信息：{cmd_output_str[:500]}", file=self.std)
            return
        
        # 复制boot.img
        print(f"\n【复制文件】复制移植后的boot.img到out目录...", file=self.std)
        Path("out/boot.img").write_bytes(Path("tmp/rom/boot.img").read_bytes())
        
        # 最终提示
        print(f"\n【打包完成】img镜像生成完毕！", file=self.std)
        print(f"  ├─ boot.img：out/boot.img", file=self.std)
        print(f"  └─ system.img：out/system.img", file=self.std)
        
        # 清理临时文件
        self.clean()
    
    def __pack_fit_size(self):
        """计算镜像适配大小"""
        total = 0
        for root, dirs, files in walk("tmp/rom/system"):
            for file in files:
                total += stat(op.join(root, file)).st_size
        return total * 1.2  # 预留20%空间

    def __readlink(self, dest: str):
        """读取符号链接"""
        if osname == 'nt':
            with open(dest, 'rb') as f:
                header = f.read(10)
                if header == b'!<symlink>':
                    return f.read().decode('utf-16').rstrip('\0')
                return None
        else:
            try:
                return readlink(dest)
            except:
                return None

    def start(self):
        """启动移植流程"""
        print(f"【开始移植】MTK低端机移植工具启动...", file=self.std)
        print(f"  ├─ 工具版本：{tool_version}", file=self.std)
        print(f"  ├─ 输出类型：{'img镜像' if self.genimg else 'zip卡刷包'}", file=self.std)
        print(f"  └─ 移植源类型：{'zip卡刷包' if self.source_type == 'zip' else '单独img镜像'}", file=self.std)
        
        try:
            self.__decompress_portzip()
            if not self.__port_boot():
                print(f"【移植失败】boot.img移植过程出错", file=self.std)
                return
            self.__port_system()
            
            if self.genimg:
                self.__pack_img()
            else:
                self.__pack_rom()
        
            print(f"\n【流程结束】移植工具执行完毕！", file=self.std)
        finally:  # 新增finally：无论成功/失败都执行清理
            self.clean()
    def clean(self):
        """清理临时文件"""
        print(f"【清理临时文件】删除tmp目录...", file=self.std)
        if Path("tmp").exists():
            rmtree("tmp")
        print(f"【清理完成】临时文件已删除", file=self.std)
        print(f"【清理残留文件】删除base目录...", file=self.std)
        if Path("base").exists():
            rmtree("base")
        print(f"【清理完成】base目录已删除", file=self.std)